# Credit_card
신용카드 사용자의 개인정보 데이터를 이용하여 신용점수를 산정하고, 사용자의 신용카드 대금 연체 정도를 예측하는 경진대회였다.

![그림3](https://user-images.githubusercontent.com/66362713/138718349-2565d91d-bed9-49ea-a192-1d002ea033ac.png)

# 데이터 설명
인덱스 번호, 성별, 차량 소유 여부, 부동산 소유 여부, 자녀수, 연간 소득, 소득 분류, 교육 수준, 결혼 여부, 생활 방식, 출생일, 업무 시작일(최초 취업 후 기간-> 3일전에 취업했으면 -3으로 표시), 핸드폰 소유 여부, 업무용 전화 소유 여부, 집전화 소유 여부, 이메일 소유 여부, 직업 유형, 가족 규모, 신용카드 발급한 월(3개월 전에 발급했으면 -3으로 표시), 신용도
이렇게 총 20가지의 feature들이 제공된다. 

마지막 신용도(credit)은 사용자의 신용카드 대금 연체를 기준으로 한 신용도로 낮게 적혀있을 수록 높은 신용의 신용카드 사용자를 의미한다.

Train set은 26457개, Test set은 10000개의 데이터가 있다. 

# 데이터 전처리
- 먼저 속성 종류와 결측치를 확인한 후 결측치를 모두 처리하였다. (NaN으로 대체)
- 이상한 부분들을 발견! (아이가 7명이 넘는 대가족이 존재한다..? TEST SET에서도 존재하는지 확인한 후 TEST 셋에서는 7명이 넘는 대가족은 존재하지 않는 것을 확인하고 관련 행들을 삭제했다.)
- index와 FALG_MOBIL은 의미 없는 변수로 판단되어 삭제하였다.
- object형식으로 이루어진 변수들은 모두 Label Encoding처리
- 업무 시작일(DAYS_EMPLOYED)에서 음수는 취업한 상태이고, 양수 혹은 0은 아직 무직상태이다. 나는 일단 알아보기 쉽도록 음수였던 수들을 양수로 바꾸고, 무직인 사람들은 0으로 바꾸었다.
- 태어난 날의 수, 신용카드 발급한 월과 같은 변수들을 위와 같이 바꾸어 주었다.
- 태어난 날의 수, 신용카드 발급한 월 등을 이용하여 파생변수를 생성
- 전체적으로 보았을 때, 연간소득 부분이 너무 크게 측정이 됨. -> MinMaxScaler을 사용하였다.

# 모델링
LGBM과  XGBoost을 사용한 결과 LGBM이 더 높았고, 여기에 OPtuna를 사용하여 최적의 파라미터 찾음

Best Score: 0.7213767871771046

단순히 LGBM을 하는 것보다 개선할 점이 필요하다고 생각함.

# 개선
사용자를 구분해야할 것같다 -> 사용자의 정보를 사용자의 아이디처럼 만들어보자!

같은 사용자여도 index는 다를 수 있는 속성들을 이용해서 하나로 이어 붙이고, 이것을 CODE로 사용. (ex) 같은 사람이 복수의 카드를 발급할 경우)
: 총수입, 성별, 차 소유, 며칠 전에 태어났는지, 며칠 전에 일을 시작했는지 등등

![그림2](https://user-images.githubusercontent.com/66362713/138718165-faf9cf42-565c-4431-b3b2-92ee33c9dfdc.png)

CODE속성이 추가된 후 CATBOOST를 사용하여 학습해봄

# 결과
Best Score: 0.6640659745264633

CATBOOST에 optuna까지 적용하니 기존496등에서 98등까지 올라옴.

![그림1](https://user-images.githubusercontent.com/66362713/138717965-a3344a73-c96b-401f-b363-091fbaad1c21.jpg)
